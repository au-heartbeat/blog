[{"categories":[""],"content":"概述 在软件开发和测试过程中，为了提高效率并减少对实际服务的依赖，我们常常使用存根服务器（Stub Server）和模拟服务器（Mock Server）这两种工具。存根服务 器和模拟服务器都是用于模拟外部依赖项的行为，但它们有不同的实现方式和用途。 本文将介绍存根服务器和模拟服务器的概念、为什么要使用存根服务器和模拟服务器，它们的优势和用途，以及如何在开发和测试中使用它们来提高效率和可靠性。 ","date":"2023-04-24","objectID":"/blog/2023/04/mocksever/:1:0","tags":[""],"title":"Mock Server and Stub Server","uri":"/blog/2023/04/mocksever/"},{"categories":[""],"content":"Mock Server ","date":"2023-04-24","objectID":"/blog/2023/04/mocksever/:2:0","tags":[""],"title":"Mock Server and Stub Server","uri":"/blog/2023/04/mocksever/"},{"categories":[""],"content":"什么是Mock Server？ Mock Server是一种模拟服务器，用于模仿API的真实行为。它通过模拟真实的服务，为来自客户端的请求提供真实响应。在开发和测试中，Mock Server发挥着重要的 作用。 它可以在本地计算机或云服务器上运行，拦截应用程序发出的请求，并返回预定义的响应。 ","date":"2023-04-24","objectID":"/blog/2023/04/mocksever/:2:1","tags":[""],"title":"Mock Server and Stub Server","uri":"/blog/2023/04/mocksever/"},{"categories":[""],"content":"为什么要使用Mock Server？ 提高开发效率 在开发过程中，某些依赖的服务可能尚未准备就绪或不可访问。使用Mock server可以模拟这些服务的行为，使开发人员能够继续工作而不会受到阻碍。有助于前端 和后端开发人员在服务尚未准备好或不可用的情况下独立进行开发。 前端团队可以利用Mock Server模拟API响应，无需等待实际后端服务的就绪，从而节省时间和资源，加快开发和测试周期。 同时，Mock Server的使用使前端和后端开发人员能够并行开发，因为它们可以依据预定义的API规范和模拟响应进行工作，而无需相互依赖。 这种独立且并行的开发方式提高了团队的整体效率，并促进了协作的灵活性和敏捷性。 模拟各种场景 Mock Server可以模拟各种请求和响应场景，包括成功响应、错误响应、边界条件和异常情况。这样可以更全面地测试应用程序的行为，提高应用程序的质量和可靠性。 隔离和独立性 Mock server允许开发人员将应用程序与外部依赖项（如第三方API或服务）隔离开来，从而使开发和测试更加独立和可控。这样可以避免对实际服务产生不必要的 依赖，提高开发效率和测试可靠性。 性能测试和负载测试 Mock server可以用于模拟高负载条件，从而进行性能测试和负载测试，以评估应用程序在真实环境中的表现。 总的来说，Mock Server的使用可以提高开发效率，支持并行开发，模拟各种场景，隔离依赖服务，并用于性能测试和负载测试。它是一个强大的工具，帮助开发人 员构建和测试应用程序，同时降低对实际服务的依赖性。 ","date":"2023-04-24","objectID":"/blog/2023/04/mocksever/:2:2","tags":[""],"title":"Mock Server and Stub Server","uri":"/blog/2023/04/mocksever/"},{"categories":[""],"content":"如何搭建Mock server？ 搭Mock Server的方式有很多种，以下是一些常见的方式： 使用Mock Server框架：有许多专门用于搭建Mock Server的框架可供选择，例如MockServer、Prism、WireMock等。这些框架提供了简单易用的接口和配置 选项，可以快速搭建和配置Mock Server。 自定义代码：可以使用编写程序语言（如Java、Python、Node.js等）来编写自定义的模拟服务器，处理来自客户端的请求，并返回预定义的响应。 使用API开发工具：一些API开发工具（如Postman、Swagger等）提供了Mock Server的功能。可以使用这些工具创建和管理Mock API，并根据需要配备设置请 求和响应。 ","date":"2023-04-24","objectID":"/blog/2023/04/mocksever/:2:3","tags":[""],"title":"Mock Server and Stub Server","uri":"/blog/2023/04/mocksever/"},{"categories":[""],"content":"常用框架 MockServer 介绍 MockServer 是一个开源模拟服务器框架，允许开发人员模拟 API 的行为。它为模拟 HTTP、HTTPS 和其他协议提供了一个强大而灵活的平台，使其适用于测试 和开发目的。对于通过 HTTP 或 HTTPS 集成的任何系统，MockServer 可用作： 模拟服务器：可以配置MockServer以针对不同的请求返回特定的响应。通过模拟真实系统的行为，MockServer能够提供一致和可控的响应，以便进行系统间的 集成测试或开发。 代理服务器：MockServer可以作为代理服务器使用，记录并可选择性地修改请求和响应。它可以拦截客户端发送的请求，并将其转发到实际的目标服务器，同时 还可以记录请求和响应的详细信息。这对于调试和监视请求的流量以及对请求和响应进行自定义处理非常有用。 同时作为代理和模拟服务器：MockServer可以同时充当代理服务器和模拟服务器。这意味着它可以根据请求的类型将其转发到实际的目标服务器或返回预定义的 响应。这种灵活性使得可以在同一个系统中同时模拟一部分请求并代理另一部分请求，以满足不同的测试或开发需求。 对于每个接收到的请求，会按照以下步骤进行处理： 查找匹配的预期并执行相应的操作。 如果没有匹配的预期，则将请求作为代理请求。 如果不是代理请求，则返回 404 响应。 MockServer 支持以下操作： 当请求符合预期时返回\"模拟\"响应 当请求符合预期时转发请求（即动态端口转发代理） 当请求匹配预期时执行回调，允许动态创建响应 当请求符合预期时返回无效响应或关闭连接 运行MockServer MockServer 非常灵活，支持多种使用模式： 通过@Before或@After方法中的Java API以编程方式 在JUnit4测试中通过@Rule注释字段使用JUnit4 @Rule 通过@ExtendWith注释的JUnit5类使用JUnit5测试扩展 通过带@MockServerTest注释的测试类使用Spring Test Execution Listener 作为任何支持Docker的环境中的Docker容器 通过任何Kubernetes环境中的Helm图表 从命令行作为测试环境中的独立进程 通过Maven插件作为Maven构建周期的一部分 作为来自任何Node.js代码的Node.js (npm) 模块 作为Grunt构建周期的一部分的Grunt插件 作为现有应用程序服务器的可部署 WAR ","date":"2023-04-24","objectID":"/blog/2023/04/mocksever/:2:4","tags":[""],"title":"Mock Server and Stub Server","uri":"/blog/2023/04/mocksever/"},{"categories":[""],"content":"Stub Server ","date":"2023-04-24","objectID":"/blog/2023/04/mocksever/:3:0","tags":[""],"title":"Mock Server and Stub Server","uri":"/blog/2023/04/mocksever/"},{"categories":[""],"content":"什么是Stub Server 服务存根是对实际服务的模拟，可用来在功能上替换测试环境中的服务。 存根服务器用于替换实际应用程序服务器。 从客户机应用程序的角度来看，服务存根看起来与其模拟的实际服务相同。 要使用服务存根来替换实际服务，必须能够将客户机应用程序中原始服务的 URL 替换为存根服务器的 URL。 ","date":"2023-04-24","objectID":"/blog/2023/04/mocksever/:3:1","tags":[""],"title":"Mock Server and Stub Server","uri":"/blog/2023/04/mocksever/"},{"categories":[""],"content":"如何搭建Stub Server 要搭建一个 Stub Server 来模拟来自真实服务器的响应，可以按照以下步骤进行操作： 选择合适的 Stub Server 工具：例如 WireMock、MockServer、JSON Server、stubby4j 等。 定义预期的请求和响应：在搭建 Stub Server 之前，需要明确要模拟的请求和对应的响应。定义请求的路径、HTTP 方法、请求头、请求体等信息，以及预期的响应状态码、响应头、响应体等信息。 配置 Stub Server：根据你选择的工具和其提供的文档，配置 Stub Server 来定义请求和响应的规则。通常可以使用配置文件、代码或 API 接口进行配置。 启动 Stub Server：根据你选择的工具，启动 Stub Server。它会监听指定的端口，等待请求到达并返回预定义的响应。 使用 Stub Server 进行测试：通过将客户端请求重定向到 Stub Server，可以测试客户端在与真实服务器交互时的行为。你可以在客户端配置中指定 Stub Server 的地址和端口，或者使用代理工具将请求重定向到 Stub Server。 通过搭建 Stub Server，你可以模拟来自真实服务器的响应，而无需实际发送请求到网络。这样可以方便地进行本地开发、测试和调试，而不受真实服务器的限制。 ","date":"2023-04-24","objectID":"/blog/2023/04/mocksever/:3:2","tags":[""],"title":"Mock Server and Stub Server","uri":"/blog/2023/04/mocksever/"},{"categories":[""],"content":"HeartBeat 使用 stubby4j 搭建Stub Server HeartBeat使用 stubby4j 作为存根服务器来构建我们的服务。所有第三方服务都存根在一个存根服务器中。 ","date":"2023-04-24","objectID":"/blog/2023/04/mocksever/:4:0","tags":[""],"title":"Mock Server and Stub Server","uri":"/blog/2023/04/mocksever/"},{"categories":[""],"content":"为何选择 stubby4j ？ 简单易用，配置使用YAML或JSON文件，对于简单的模拟场景可以快速上手。 专注于HTTP和HTTPS服务的模拟和stubbing，可以快速创建stub并定义所需的响应。 支持动态响应生成和JavaScript注入。 可以运行在本地计算机上，不需要额外的服务器或环境。 总的来说，stubby4j更加简单易用，适合快速创建简单的模拟场景。 ","date":"2023-04-24","objectID":"/blog/2023/04/mocksever/:4:1","tags":[""],"title":"Mock Server and Stub Server","uri":"/blog/2023/04/mocksever/"},{"categories":[""],"content":"使用stubby4j HTTP 存根服务器的优点 模拟来自真实服务器的响应并且不关心（或不能）通过网络发送请求 在基于 Docker 的微服务架构中存根外部 Web 服务（在本地开发和测试时） 当您依赖的外部 API 不存在或不完整时，避免对生产力产生负面影响 模拟实际远程 API 无法可靠生成的 Web 服务的边缘情况和/或故障模式 错误注入，在相同 URI 上的 X 次良好响应之后，Web 服务可以得到错误的响应 验证用户的应用程序在 WebSocket 服务器推送时的行为是否符合预期 验证用户代码是否使用所有必需的参数和/或标头发出 HTTP/1.1 或 HTTP/2（通过 TLS）请求 验证用户代码是否正确处理 HTTP 响应错误代码 ","date":"2023-04-24","objectID":"/blog/2023/04/mocksever/:4:2","tags":[""],"title":"Mock Server and Stub Server","uri":"/blog/2023/04/mocksever/"},{"categories":[""],"content":"运行 Stub Server 使用 JAR 存档运行 下载 stubby4j：下载最新版本的 stubby4j latest stubby4j version。 编写存根配置：创建一个 YAML 或 JSON 文件，用于定义存根的配置。在配置文件中，定义请求的 URL、HTTP 方法、请求头、请求体以及对应的响应。 配置存根文件：将编写好的存根配置文件保存在合适的位置，以便 stubby4j 可以读取并加载配置。 启动 stubby4j：使用命令行或脚本运行 stubby4j，指定配置文件的路径。例如，使用以下命令行启动 stubby4j： java -jar stubby4j.jar -d config.yaml 验证 stub server：一旦 stubby4j 启动成功，通过访问指定的端口和路径来验证 stub server 是否正常工作。 使用 docker-compose 运行 要使用Docker Compose运行stubby4j，你可以按照以下步骤进行操作： 安装Docker和Docker Compose 创建一个名为docker-compose.yml的文件，指定镜像、端口映射、文件挂载以及启动命令等 编写存根配置：创建一个 YAML 或 JSON 文件，用于定义存根的配置 启动 stubby4j：切换到包含docker-compose.yml文件的目录，运行以下命令启动stubby4j容器： docker-compose up -d 验证 Stub Server：通过指定路径和端口来访问stubby4j的Web界面，并通过该界面管理和测试API存根。 以上步骤将帮助你使用Docker Compose运行stubby4j，并通过配置文件定义API存根。你可以根据自己的需要修改配置文件，并在容器中重新启动stubby4j来更新配置。 ","date":"2023-04-24","objectID":"/blog/2023/04/mocksever/:4:3","tags":[""],"title":"Mock Server and Stub Server","uri":"/blog/2023/04/mocksever/"},{"categories":[""],"content":"构建示例 HeartBeat 是了解项目交付情况的工具，可帮助团队确定绩效指标，从而推动持续改进并提高团队生产力和效率。 其中关键指标有： Velocity Cycle Time Classification Deployment Frequency Meantime To Recovery Change Failure Rate 为了计算上述指标，系统需要获取到Jira、BuildKite、Github 的相关信息。在开发过程中，为了实现前后端分离开发， 构建了 Stub Server，用于存根第 3 方服务（Jira、BuildKite 和 Github），以促进开发进程和端到端测试。 HeartBeat stub 结构 stubs backend buildkite github jira frontend config board.json pipeline.json sourceControl.json exportPage stubs.yml docker-compose.yml stub-service.yaml stubs.yml 如上所示，HeartBeat 项目中的所有关于 Stub Server 的代码在 stub 目录下,包括了backend，frontend 和 配置文件。 服务配置 docker-compose.yml version: '3.4' services: stubs: image: azagniotov/stubby4j:latest-jre11 volumes: - \"./:/home/stubby4j/data\" container_name: stubby4j_jre11 ports: - 4323:4323 - 8882:8882 - 8891:8891 - 7445:7445 environment: YAML_CONFIG: stubs.yaml LOCATION: 0.0.0.0 STUBS_PORT: 4323 ADMIN_PORT: 8891 STUBS_TLS_PORT: 7445 WITH_ARGS: \"--enable_tls_with_alpn_and_http_2 --debug --watch\" image: 指定了 stubs 服务所使用的 Docker 镜像 container_name: 指定了容器的名称 volumes: 指定了容器与主机之间的文件卷映射关系 ports: 配置了容器与主机之间的端口映射关系 environment: 设置了容器的环境变量 通过以上配置，可以运行一个使用 stubby4j 的 Docker 容器，将容器内的端口映射到主机上，从而可以通过主机上的相应端口访问 stubby4j 服务。 stubs.yml includes: ./stub-service.yaml ./backend/jira/jira-stubs.yaml ./backend/github/github-stubs.yaml ./backend/buildkite/buildkite-stubs.yaml ./frontend/stubs.yaml ./stub-service.yaml： 配置了请求的响应规则 ./backend/jira/jira-stubs.yaml： 是用于配置与 Jira 后端相关的 stubs（模拟服务) ./backend/github/github-stubs.yaml： 是用于配置与 GitHub 后端相关的 stubs ./backend/buildkite/buildkite-stubs.yaml： 是用于配置与 Buildkite 后端相关的 stubs ./frontend/stubs.yaml： 是用于配置前端相关的 stubs stub-service.yaml - request: method: GET url: /health response: status: 200 body: \u003e {\"status\": \"OK\"} headers: content-type: application/json 该配置文件定义了一个针对 /health 路径的 GET 请求的响应规则。 request 部分定义了请求的属性，包括请求方法和请求 URL。 response 部分定义了响应的属性，包括响应状态码、响应体和响应头。 这段配置表示当收到 /health 路径的 GET 请求时，stubby4j 会返回一个状态码为 200 的响应，响应体为 {“status”: “OK”}，同时设置响应头中的 content-type 为 application/json。 具体服务配置 以 Jira 为例，每个 stub 服务都需要 json 和 yaml 文件来指定具体服务的请求参数和响应内容。 # Board Configuration - request: method: GET url: /rest/agile/1.0/board/1963/configuration response: headers: content-type: application/json status: 200 file: ./backend/jira/jsons/jira.board.1963.configuration.json 该文件配置了针对 /rest/agile/1.0/board/1963/configuration 路径的GET请求的响应规则。 request 部分定义了请求的属性，包括请求方法和请求 URL。 response 部分定义了响应的属性，包括响应头、响应状态码和响应体。 file 属性指定了响应体的内容来自于指定的文件。在上述例子中，响应体的内容将从 ./backend/jira/jsons/jira.board.1963.configuration.json 文件中读取。 当收到/rest/agile/1.0/board/1963/configuration 路径的 GET 请求时，stubby4j 会返回一个状态码为 200 的响应， 响应头中的 content-type 设置为 application/json，响应体的内容将从jira.board.1963.configuration.json文件中读取并返回。 服务启动 导航到 /Heartbeat/stubs 文件夹 执行以下命令： docker-compose up -d 导航到以 http://localhost:4323/ 开头的URL 如何新建一个stub api 在 stub/服务名称/jsons 文件夹中创建响应的json 文件 创建 stub/服务名称/xxx-stubs.yaml 文件来配置来映射存根请求和响应 在stub/stubs.yml引入新的配置文件 最后，创建PR时，将标签\"[stub]“添加到标题信息中，触发mockserver的重新部署 ","date":"2023-04-24","objectID":"/blog/2023/04/mocksever/:4:4","tags":[""],"title":"Mock Server and Stub Server","uri":"/blog/2023/04/mocksever/"},{"categories":[""],"content":"使用 GitHub Actions 实现Heartbeat CI/CD 有关于CI/CD的概念，想必大家都非常熟悉。今天跟大家分享这篇文章，主要是想分享记录一下，在HeartBeat内部项目中，我们怎么实现代码的CI/CD的。我主要从以下几方面来跟大家分享。 CI/CD的简单概述 部署CI/CD的工具 GitHub Actions以及Why use it? How to use GitHub Action? 线上部署 ","date":"2023-04-24","objectID":"/blog/2023/04/cicd/:1:0","tags":[""],"title":"CI/CD","uri":"/blog/2023/04/cicd/"},{"categories":[""],"content":"CI/CD CI指持续集成（Continuous Integration） CD指持续交付/持续部署（Continuous Delivery/Continuous Deployment）的缩写。 持续集成是指在开发过程中，团队成员经常地提交代码到一个共享代码仓库中，然后自动地进行构建、测试、代码质量检查等流程，以尽早地发现和解决潜在的问题。 持续交付/持续部署则是指将已经通过了所有自动化测试的代码，自动地部署到生产环境中，以提高软件交付的速度和质量，并且可以快速地响应客户需求和反馈。 ","date":"2023-04-24","objectID":"/blog/2023/04/cicd/:1:1","tags":[""],"title":"CI/CD","uri":"/blog/2023/04/cicd/"},{"categories":[""],"content":"部署CI/CD的工具 部署 CI/CD 的工具有很多，下面我就简单列举一些主流的工具及其优缺点. 工具名 优点 缺点 Jenkins 开源、免费、功能强大、插件丰富，可与各种工具集成，支持多个操作系统 需要自己维护和扩展 Travis CI 适用于开源项目，易于设置和使用，集成度高，支持多种编程语言和框架 需要付费才能获得更高级别的功能和支持 GitHub Actions 与GitHub 版本控制系统无缝集成，可以轻松配置和触发 CI/CD 流程 如果需要更高的并发能力，则需要升级到付费版本；相比一些专业的 CI/CD 工具，GitHub Actions 在某些高级功能和自定义配置方面可能受到一定的限制 BuildKite 简单易用，可扩展性，可视化界面 需要自行设置和维护服务器资源，需要编写配置文件，可能会受限于插件和集成的可用性 ","date":"2023-04-24","objectID":"/blog/2023/04/cicd/:1:2","tags":[""],"title":"CI/CD","uri":"/blog/2023/04/cicd/"},{"categories":[""],"content":"GitHub Actions GitHub Actions是一个持续集成和持续部署（CI/CD）平台，由GitHub提供。使用GitHub Actions，可以在代码存储库中配置和自动化软件开发生命周期中的工作流程，包括测试、构建和部署。同时它与GitHub无缝集成：GitHub Actions与GitHub代码仓库紧密集成，可以直接在代码仓库中编写和管理工作流程，方便使用和管理。 HeartBeat是我司的内部项目，其是一种帮助团队了解项目交付情况的度量工具，包括可以计算团队一段时间内的代码部署频率，需求卡的完成情况等，通过分析这些指标并作出相应的改进措施从而推动并提高团队生产力和效率。但团队还没获取一些付费资源的支持。基于此，我们选择GitHub Actions部署项目CI/CD，并且免费的资源完全支持项目当前运行。 ","date":"2023-04-24","objectID":"/blog/2023/04/cicd/:1:3","tags":[""],"title":"CI/CD","uri":"/blog/2023/04/cicd/"},{"categories":[""],"content":"HeartBeat code structure HeartBeat 项目中的所有代码在一个总的Heartbeat目录下,其中包括了前端代码，后端代码，stub(mock server)等。 而.github目录下主要存了GitHub actions的流水线配置信息;docs目录存的主要是Heartbeat的官网信息文档,且不断在更新当中;ops下存了与基础设施相关的配置信息，包括管理AWS资源的cloudformation.yml文件,还有前端，后端，mock server(stub)的Dockerfile。讲项目结构的原因是我们的流水线的各个job是与其紧密相连的。 ","date":"2023-04-24","objectID":"/blog/2023/04/cicd/:1:4","tags":[""],"title":"CI/CD","uri":"/blog/2023/04/cicd/"},{"categories":[""],"content":"Heartbeat .github workflows BuildAndDeploy.yml Docs.yml Welcome.yml backend gradle java client config controller exception service test docs src components layouts pages frontend test cypress src assets clients components hooks layouts pages utils ops infra cloudformation.yml docker-compose.yml Dockerfile.backend Dockerfile.frontend Dockerfile.stub stubs backend buildkite github jira frontend board.json pipeline.json sourceControl.json ","date":"2023-04-24","objectID":"/blog/2023/04/cicd/:1:5","tags":[""],"title":"CI/CD","uri":"/blog/2023/04/cicd/"},{"categories":[""],"content":"如何使用GitHub Actions部署CI/CD 在你的GitHub上的存储库中创建一个目录.github/workflows 在该.github/workflows目录中，创建一个名为buildAndDeploy.yml的文件，该文件就是设计组织pipeline结构的主要文件。其主干代码如下： 其中jobs下的每一项都是我们pipeline运行过程的一个步骤。 name: Build and Deploy on: push: branches: [ \"*\" ] pull_request: branches: [ \"main\" ] workflow_dispatch: jobs: shellcheck: security-check: backend-check: backend-license-check: frontend-check: frontend-license-check: deploy-infra: if: ${{ github.ref == 'refs/heads/main' }} needs: - frontend-check - backend-check - security-check - shellcheck - frontend-license-check - backend-license-check build-backend: if: ${{ github.ref == 'refs/heads/main' }} needs: - deploy-infra build-frontend: if: ${{ github.ref == 'refs/heads/main' }} needs: - deploy-infra build-mock-server: if: ${{ github.ref == 'refs/heads/main' }} needs: - deploy-infra deploy-e2e: runs-on: ubuntu-latest needs: - build-backend - build-frontend deploy-stub: runs-on: ubuntu-latest needs: - build-mock-server e2e: runs-on: ubuntu-latest defaults: run: working-directory: ./frontend needs: - deploy-e2e - deploy-stub deploy: runs-on: ubuntu-latest needs: - e2e 以上命令结果如下图所示 BuildAndDeploy 3. 触发流水线（流水线的触发条件是什么呢？） 主要有两种：1）feature branch的任意提交； 2）将feature branch上的pr合并到main分支。 第一种只会触发一些检查工作，包括代码安全性检查，许可证检查，shell脚本检查，并不会触发前后端代码的构建镜像和部署。 第二种情况是将pr合并到main后才会触发，此时触发整个流水线，除了之前的代码检查，还包括镜像构建和部署SIT。 name: Build and Deploy on: push: branches: [ \"*\" ] pull_request: branches: [ \"main\" ] workflow_dispatch: 因此，相应在yaml文件中需要添加条件判断，如以下代码所示： if: ${{ github.ref == 'refs/heads/main' }} 不同条件下触发的job不同 执行流水线是需要花费一定的时间的，而流水线中不是所有job都每次触发。例如，当没有对mock server(stub)做任何改变的时候，可以不触发对应job， 或是对于infra相关的配置，如果没有任何更改，也不需要触发。这种按需触发可以节省流水线总的运行时间。 那如何控制呢？就是在对应的job中添加条件判断. 例如针对mockServer 的触发，可以根据commitMessage中包含[stub]字段去触发，反之则不执行。 - name: Build, tag for MockServer if: ${{ contains(github.event.head_commit.message, '[stub]') }} env: REGISTRY: ${{ steps.login-ecr.outputs.registry }} REPOSITORY: heartbeat_stub IMAGE_TAG: \"hb${{ github.run_number }}\" run: | docker build -t $REGISTRY/$REPOSITORY:latest ./ -f ./ops/infra/Dockerfile.stub docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG ./ -f ./ops/infra/Dockerfile.stub 上述代码是build-mock-server job中的一个构建mock server镜像的step，其中代码if: ${{ contains(github.event.head_commit.message, '[stub]') }} 的作用为：当触发流水线的最新一条提交信息里有[stub]标记时，才会执行当前step。相应，开发者在部署对应step时，需要在commit_message 添加[stub]标记，以此触发step的构建和部署。 5. 不同jobs里边的依赖关系 如何建立流水线之间各个job之间的连接呢？例如执行完代码检查后，执行镜像构建。 以部署deploy-infra为例，其代码如下所示： deploy-infra: if: ${{ github.ref == 'refs/heads/main' }} needs: - frontend-check - backend-check - security-check - shellcheck - frontend-license-check - backend-license-check 至此，用GitHub Actions搭建的Heartbeat pipeline就成功啦。 那如何快速查看工作流程结果呢？ 这里将以HeartBeat CI/CD部署为例，查看工作流程结果。 进入GitHub仓库主页，单击 Actions GitActionIcon 在左侧边栏中，单击要显示的工作流. GitActionJobs 从工作流程运行列表中，单击要查看的运行名称，以为“frontend checked举例，正在测试 GitHub Actions”。 DetailSteps 日志显示每个步骤是如何处理的。展开任何步骤以查看其详细信息。 DetailInfoAboutEachStep 以下是HeartBeat完整CI/CD workFlows BuildAndDeploy ","date":"2023-04-24","objectID":"/blog/2023/04/cicd/:1:6","tags":[""],"title":"CI/CD","uri":"/blog/2023/04/cicd/"},{"categories":[""],"content":"线上部署 上述内容基本描述了在HeartBeat上是如何设计和触发GitHub Actions pipeline，那项目最终部署到了哪里呢？ 首先,针对HB项目，主要构建了三个镜像：后端镜像，前端镜像和mock server的镜像，并将以上内容部署到了AWS云服务上。 在本项目中主要有两套环境：(1) e2e环境，(2)SIT环境，二者分别部署在两个AWS EC2上。 e2e上包含前端，后端，mock server镜像，只是后端容器服务连接的是mock server。 SIT环境上包含两个镜像，前端和后端，但后端连接的是真实的第三方服务。两套EC2环境设计图如下所示。 EC2-design 首先本项目构建的镜像会存放到AWS的ECR(Elastic Container Registry)上，建立了三个repository分别存放前端，后端和mock server镜像。如下图所示。 ECR 后端镜像仓库如下图所示。 ECR-Backend 最终构建好的镜像会被部署到下图所示的两个EC2实例上，第一个是SIT环境，另外一个是e2e环境。 EC2-list 例如进入到e2e的环境上，查看运行的容器如下图所示。 EC2-e2e e2e环境中，总共有三个容器在运行，容器的启动是由docker-compose 编排控制的，通过传递不同的环境变量让后端服务连接mock server而非真实第三方服务。 ","date":"2023-04-24","objectID":"/blog/2023/04/cicd/:1:7","tags":[""],"title":"CI/CD","uri":"/blog/2023/04/cicd/"},{"categories":[""],"content":"Deadline 需给每个文章设置Deadline， 并放置在文章顶部 2023-05-31 ","date":"2023-04-15","objectID":"/blog/2023/04/requirement/:1:0","tags":[""],"title":"Blog 要求","uri":"/blog/2023/04/requirement/"}]